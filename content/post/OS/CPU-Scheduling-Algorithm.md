---
title: "CPU 스케줄링 알고리즘(CPU Scheduling Algorithm)에 대해 공부해보자"
date: 2023-09-23T22:40:57+09:00
draft: true
categories :
- Algorithm
---

# CPU 스케줄링 알고리즘
## CPU 스케줄링 알고리즘이란?
운영체제는 CPU 스케줄링을 통해 메모리에 있는 프로세스 중, 어떤 프로세스에게 해당 CPU를 할당할 것인지 결정한다. CPU는 프로세스들이 다음과 같은 상황일 때 스케줄링을 결정한다.
1. 실행 상태에서 대기 상태로 전환될 때 (ex: I/O 발생)
2. 실행 상태에서 준비 상태로 전환될 때 (ex: 인터럽트 발생)
3. 대기 상태에서 준비 상태로 전환될 때 (ex: I/O 완료)
4. 종료될 때

1번과 4번 상황에서 스케줄링이 발생하는 것을 비선점형 스케줄링이라고 한다. 이외의 모든 스케줄링은 선점형 스케줄링이라고 한다.

### 비선점형 스케줄링 (Non-Preemptive)
- 프로세스가 CPU를 점유하고 있다면 뺏을 수 없는 방식
- 프로세스에 CPU가 할당되면, 해당 프로세스가 종료 또는 I/O 처리를 위해 CPU를 방출할 때까지 CPU를 점유한다.
- 필요한 문맥 교환만 일어나므로 오버헤드가 상대적으로 적지만, 프로세스의 배에 따라 효율성 차이가 많이 난다.

### 선점형 스케줄링 (Preemptive)
- 프로세스가 CPU를 할당받아 실행 중이더라도 CPU가 이를 뺏을 수 있는 방식
- CPU 처리 시간이 매우 긴 프로세스가 CPU를 독점하는 상황을 막을 수 있어 효율적으로 운영이 가능하다.
- 잦은 문맥 교환으로 오버헤드가 커질 수 있다.

## 1. 선입 선처리 알고리즘 (First-Come, First-Served Scheduling : FCFS)
- CPU를 먼저 요청하는 프로세스에게 해당 CPU가 할당되는 알고리즘
- 이는 선입선출(FIFO) Queue를 통해 쉽게 관리할 수 있다.
- 비선점형 스케줄링
  - 평균 대기 시간이 길어질 수 있다.
- 호위효과가 발생할 수 있다.

### 호위효과란?
- 다른 프로세스가 하나의 긴 프로세스가 CPU를 놓기를 기다리는 상황

## 2. 최단 작업 우선 스케줄링 (Shortest Job First : SJF)
- 각 프로세스의 next CPU burst 길이를 고려한 알고리즘
- CPU 이용이 가능해지면, CPU burst 길이가 가장 작은 프로세스에게 CPU를 할당한다.
- 프로세스가 동일한 CPU burst를 가지고 있다면, 선입 선처리 스케줄링이 적용된다.
- 비선점형과 선점형이 각각 존재한다.
- 평균 대기 시간을 줄일 수 있다.
- 다음 프로세스의 CPU burst 길이를 예측하는 것이 어렵다는 단점이 있다.

### 비선점형 SJF
- 실행되고 있는 프로세스는 끝가지 실행시킨다.

### 선점형 SJF
- 현재 실행되고 있는 프로세스의 남은 시간보다 더 빨리 끝날 수 있는 프로세스에게 CPU를 할당한다. Shortest Remaining Time First(SRTF)라도고 부른다.

## 3. 라운드 로빈 스케줄링 (Round Robin Scheduling)
- 각 프로세스에 동일한 CPU 할당 시간을 부여하여 해당 시간 동안만 CPU를 이용할 수 있게 하는 알고리즘
- 할당 시간 내에 처리하지 못하면 다음 프로세스로 넘어가기 때문에 선점형 방식이다.
- n개의 프로세스가 있을 때, 할당 시간을 q라고 하면 어떤 프로세스도 (n-1)q 보다 많은 시간을 기다리지 않게 된다.
- 응답 시간을 빠르게 할 수 있다는 장점이 있다.
- q가 커지면 결국, 선입 선처리 알고리즘처럼 작동된다.
- q가 매우 작아지면 context switching이 자주 발생하게 된다.
- 시간 할당량은 문맥 교환 시간보다 커야 한다. > 그렇지 않으면 오버헤드가 발생해 성능이 저하된다.

## 4. 우선순위 스케줄링 (Priority Scheduling)
- 가장 높은 우선순위를 가진 프로세스에게 CPU를 할당하는 알고리즘
- 우선순위가 같은 프로세스가 있다면 선입 선처리 스케줄링이 적용된다.
- 최단 작업 우선 스케줄링도 우선순위 스케줄링이라고 할 수 있다. (다음 CPU burst time이 우선순위로 작용하듯이)
- 기아 문제가 발생할 수 있고, 해당 문제를 해결하기 위해 노화를 사용할 수 있다.
> 기아 문제(Starvation Problem) / 노화(aging) ?
> 
> - 기아 문제 : 낮은 우선순위를 가진 프로세스가 영원히 실행되지 않는 문제이다.
> - 노화 : 시간이 지날수록 프로세스의 우선순위를 높여주는 방법


### 비선점형 우선순위 스케줄링
- 준비 완료 Queue에 새로운 프로세스를 넣는다.

### 선점형 우선순위 스케줄링
- 실행되고 있는 프로세스의 우선순위보다 높은 우선순위를 가진 프로세스가 있으면 해당 프로세스에 CPU를 할당하여 Switching Context가 발생한다.

### 우선순위 + 라운드 로빈 스케줄링
- 우선순위가 가장 높은 프로세스를 실행하고, 우선순위가 같은 프로세스들은 라운드 로빈 스케줄링을 사용하여 스케줄하는 방식

## 5. 다단계 큐 스케줄링 (Multilevel Queue Scheduling)
- 우선순위마다 별도의 Queue를 가진다.
- 우선순위가 높은 큐에서 프로세스들을 스케줄한다.
- 각 큐에서 프로세스들은 이동할 수 없다. > 기아현상이 발생할 수 있다.
- Foreground 프로세스들은 라운드 로빈 스케줄링 방식을 사용하고, Background 프로세스는 선입 선처리 스케줄링을 사용한다.

## 6. 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue Scheduling)
- 다단계 피드백 큐 스케줄링에서는 각 큐에서 프로세스들이 이동할 수 있는 방식이다.
- 새로운 프로세스는 모두 첫 번째 큐에 들어간다. 그리고 라운드 로빈 스케줄링 방식이 이루어진다.
- 낮은 우선순위 큐는 선입 선처리 스케줄링 방식으로 진행되는데 너무 오래 대기하는 프로세스는 큐를 옮길 수 있다. == 노화를 이용하여 기아 문제를 해결함.