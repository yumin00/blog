---
title: "캐시 메모리(Cache Memory)에 대해 알아보자"
date: 2023-09-27T23:33:10+09:00
draft: false
categories :
- ComputerStructure
---

# 캐시 메모리 (Cache Memory)
## 캐시 메모리란?
![image](https://github.com/yumin00/blog/assets/130362583/061339b3-beb0-40dd-b48c-4bd782157cf1)
캐시 메모리란 CPU의 처리 속도와 메모리(주기억장치)의 접근 속도 차이를 줄이기 위해 사용하는 메모리이다.
메인 메모리에 있는 데이터를 캐시 메모리에 불러와 두고,
프로세서가 필요한 데이터를 캐시 메모리에서 찾을 수 있도록 함으로써 속도를 빠르게 할 수 있다.

데이터 요청이 들어오면, 먼저 캐시에서 데이터를 탐색한다. 캐시가 없거나 오래된 경우 메모리에서 데이터를 조회한다.
이후 캐시에도 데이터를 복사/갱신하며 오래된 데이터는 삭제한다.

## 캐시 메모리 특징
![image](https://github.com/yumin00/blog/assets/130362583/c0f291d0-d0a7-4763-9ca7-8f0130ebd5a0)
- 주기억장치와 CPU 사이에 위치하여, 자주 사용하는 프로그램과 데이터를 기억한다.
- 메모리 계층 구조에서 레지스터 다음으로 상위에 위치한다.
- 캐시메모리를 사용하면 주기억장치에 접근하는 횟수를 줄일 수 있기 때문에 컴퓨터의 처리 속도가 향상된다.
- 캐시 주소표는 검색시간을 단축시키기 위해 주로 연관 기억장치를 사용한다.

## 데이터 지역성 (Data Locality)
데이터 지역성이란 프로그램 실행 중 데이터와 명령어에 대한 접근 패턴을 최적화하여 캐시 메모리의 효율성을 높이는 중요한 개념이다.
데이터 지역성은 주로 두 가지 유형으로 나눌 수 있다.

### 공간 지역성 (Spatial Locality)
공간 지역성이란 CPU가 특정 메모리 위치에 접근할 때, 인접합 메모리 위치에도 곧 접근할 가능성이 높다는 것을 의미한다.

캐시는 메모리 블록 단위로 데이터를 저장하기 때문에, 하나의 블록에 있는 데이터를 접근할 때 그 블록의 다른 데이터도 함께 캐시에 로드된다.

ex) a[0], a[1]과 같은 연속 접근 시, 참조된 데이터 주변의 데이터가 잠시후 사용될 가능성이 높다.

### 시간 지역성 (Temporal Locality)
시간 지역성이란, 한 번 찾아진 데이터는 가까운 시간 내애에 다시 접근될 가능성이 높다는 것을 의미한다.

시간 지역성은 데이터가 캐시 메모리에 남아 있을 때 다시 접근하여 빠른 속도를 유지하는 데 도움을 준다.

ex) for, while과 같은 반복문에서 사용되는 변수는 다시 한 번 사용될 가능성이 높다.

## 적중과 실패
캐시 메모리가 있는 컴퓨터 시스템은 CPU가 메모리에 접근하기 전 먼저 캐시 메모리에 원하는 데이터가 있는지 데이터의 존재 여부를 확인한다.
- 적중(hit) : 필요한 데이터가 있는 경우
- 실패(miss) : 필요한 데이터가 없는 경우
- 적중률(hit ratio) : 요청한 데이터를 캐시 메모리에서 찾을 확률 / 캐시 메모리의 성능은 적중률에 의해 결정된다.

보통 CPU는 데이터를 가져오기 위해 캐시 메모리 > 메모리 > 보조기억장치 순으로 접근한다.
- 캐시 적중일 경우 : 캐시 메모리의 데이터를 CPU 레지스터에 복사한다.
- 캐시 실패/메모리 적중일 경우 : 메모리의 데이터를 캐시 메모리에 복사하고, 캐시 메모리의 복제된 내용을 CPU 레지스터에 복사한다.
- 캐시, 메모리 실패일 경우 : 보조기억장치의 데이터를 메모리에 복사한다. 메모리에 복제된 데이터를 캐시 메모리에 복제한다. 캐시 메모리의 복제된 데이터를 레지스터에 복제한다.

## 캐시 메모리 매핑 (Mapping)
캐시 메모리와 주기억장치 사이에 데이터를 옮기는 것을 매핑이라고 한다.

메인 메모리에서 캐시로 데이터를 저장할 때, 공간 지역성 때문에 해당 데이터의 주변까지 캐시 메모리에 복제한다.
이때 단위를 블록(block)이라고 한다. 그리고 메인 메모리의 몇 번재 블록인지 알려주는 태그도 함께 저장한다. 

### 직접 매핑
![image](https://github.com/yumin00/blog/assets/130362583/e70a8b8c-ffc6-48ad-b320-728f5242c441)
직접 매핑은 메인 메모리에서 데이터 블록을 가져올 때, 메인 메모리와 동일한 배열을 갖도록 캐시 메모리에 복제하는 방법이다.

복제하는 방법이 단순하고, 탐색이 쉽다는 장점이 있다. 하지만 여러 블록이 동일한 캐시 블록에 매핑될 수 있기 때문에 충돌이 발생하여 적중률이 낮을 수 있다.

### 연관 매핑
![image](https://github.com/yumin00/blog/assets/130362583/37599c46-2edc-4938-9ee9-f8d829a7c173)
직접 매핑의 단점은 보완하기 위해 나온 매핑 방법이다.
캐시에 저장된 데이터들은 메인 메모리에 저장된 순서와 무관하다. 때문에 캐시 메모리에 접근하면, 태그가 같은 데이터가 있는지 찾는 작업이 필요하다.

따라서 시간이 오래 걸린다는 단점이 있지만 적중률이 높다는 장점이 있다.

### 집합 연관 매핑
![image](https://github.com/yumin00/blog/assets/130362583/0ab1176a-586b-4ac9-ba32-3e73ea92c14b)
직접 매핑의 단순한 회로와 연관 매핑의 높은 적중률이라는 장점만을 가져와 탄생한 매핑 방법이다.

직접 매핑처럼 메모리 블록은 정해진 인덱스만 들어갈 수 있지만, 블록이 여러 개의 집합으로 이루어져 있어 그 집한 내의 아무 자리에 들어가면 된다.

## 캐싱 메모리 정책
### Write Through
데이터를 추가하거나 업데이트할 때 캐시에 동시에 하는 전략이다.

둘 다 업데이트하여 일관성을 유지하기 때문에 안정적이라는 장점이 있다.
하지만, 속도가 느린 장치를 사용하면 성능이 떨어진다는 단점이 있다.

해당 방식은 데이터 로스가 발생하면 안되는 곳에서 사용한다.

### Write Back
데이터를 캐시에 먼저 저장하고, 일정 기간 혹은 일정 크기가 됐을 때 캐시에 모여있는 데이터를 메모리에 저장한 후, 해당 캐시에 있던 데이터를 삭제하는 방식이다.

속도가 빠르다는 장점이 있지만, 캐시는 업데이트를하고 메모리에는 바로 업데이트가 되지 않기 때문에 서로 다른 값이 발생할 수 있다.

빠른 서비스를 요하는 서비스에서 사용한다.