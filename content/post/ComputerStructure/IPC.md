---
title: "IPC(Inter Process Communication)에 대해 알아보자"
date: 2023-08-23T13:08:43+09:00
draft: false
categories :
  - ComputerStructure
---

# IPC
## 1. IPC 개념
**프로세스는 독립적으로 실행된다.**

**IPC(Inter Process Communication)** 란 프로세스 간의 통신을 위한 매커니즘이다.

이때,프로세스란 무엇일까?

---

> ### 프로세스
프로세스는 실행 중인 프로그램을 의미한다. 그렇다면 프로그램은 무엇일까?

프로그램이란, 명령어들의 모음을 포함한 디스크에 저장된 파일이다. 프로그램이 실행되면, 명령어들과 데이터가 메모리에 적재되고 이것이 프로세스가 된다.

> ### 프로세스 메모리 구조
<img width="300" alt="image" src="https://github.com/yumin00/blog/assets/130362583/cea79ecd-9aa4-4f00-9366-9a39f48fcb25">

프로세스에 대한 더 자세한 내용은 [여기](https://yumin.dev/p/process-vs-program-vs-thread/)에서 확인할 수 있다.

> ### 프로세스 스케줄링
하나의 CPU로 프로세스를 동시에 실행시킬 수 없다. 그래서 CPU는 여러 프로세스를 일정한 기준으로 순서를 정해서 실행한다. CPU 할당 순서 및 방법을 결정하는 과정을 프로세스 스케줄링이라고 한다.

---

프로세스는 독립적으로 실행되기 때문에, 서로 간에 통신이 어렵다는 문제가 있다. 커널 영역에서는 IPC라는 내부 프로세스간 통신을 제공한다.

> 커널영역?
> 
> 프로세스 메모리의 코드 영역, 데이터 영역, 힙 영역, 스택 영역은 사용자 영역으로, 이를 제외한 나머지 영역이 커널영역이다.
> 
> 운영체제 코드는 커널 영역에서만 실행 가능하고, 사용자는 **시스템 콜**을 통해 커널 영역을 실행할 수 있다.

IPC 모델에는 **Shared Memory**, **Message Passing** 이 있다.

## 2. IPC 모델 - Shared Memory
<img width="1471" alt="image" src="https://github.com/yumin00/blog/assets/130362583/b2224069-d99e-4196-b0fb-fb622cf98e32">

**Shared Memory(메모리 공유)** 는 프로세스끼리 공통의 메모리 영역을 상호간 통신하는 방법이다.

데이터 자체를 공유하도록 지원하며, 한 프로세스에서 변경한 메모리 공간의 내용을 다른 프로세스에서 접근할 수 있다. 공유 메모리는 커널에서 관리된다.

이는 성능은 좋지만, 동기화 문제가 발생한다.

### 동기화 문제
동시에 공유 자원에 접근하는 것은 데이터의 일관성을 해칠 수 있다. 프로세스들의 실행 순서를 정하여 공유 자원의 일관성을 보장하는 것을 동기화(Synchronization)라고 한다.

IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해, **세마포어**와 **뮤텍스**를 사용하여 동기화 문제를 해결할 수 있다. (세마포어, 뮤텍스는 [여기](https://yumin.dev/p/%EC%8A%A4%ED%95%80%EB%9D%BDspin-lock-vs-%EB%AE%A4%ED%85%8D%EC%8A%A4mutex-vs-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4semaphore/)에서 더 자세히 알아볼 수 있다)

## 3. IPC 모델 - Message Passing
### Message Passing(메시지 전달)
**Message Passing(메시지 전달)** 은 커널이 제공하는 API를 이용하여 커널 공간을 통해 통신하는 방식이다.

송신 프로세스가 커널로 메시지를 보내면 그걸 커널이 수신 프로세스에게 보내주는 것이다.

### direct communication (커널의 직접 전달)
**direct communication** 은 송신 프로세스가 커널에 메시지를 주고, 그걸 커널이 수신 프로세스에게 직접 전달하는 것이다.

이때, 송싱 프로세스는 통신하려는 프로세스의 이름을 명시적으로 표기하여 메시지를 전달한다.

### indirect communication (커널의 간접 전달)
**indirect communication** 은 중간에 mailbox라는 중간 매체를 통하여 메시지를 주고 받는 것이다. 
송신 프로세스가 커널에게 'm0 이라는 메시지 박스에 메시지를 넣어놓을테니 수신 프로세스에게 메시지를 전달해줘' 라고 하면, 수신 프로세스가 커널에서 m0 메시지 박스에서 메시지를 읽는 방식이다.

### 장단점
- 커널의 중계를 통해 메시지를 전달하며 큐를 사용하여 비교적 안전
- 커널의 한 구석에 저장 공간이 필요함
- 직접 전달하는 것보다 속도가 느림
- 매번 system call 이 호출됨
- queue에서 저장하고 꺼내는 과정에 발생하는 오버헤드로 인해 효율성이 떨어짐

> Overhead(오버헤드)
> 
> 프로그램 실행 도중에 동떨어진 위치의 코드를 실행시켜야할 때, 추가적으로 시간/메모리/자원이 사용되는 현상

메시지 전달 방식에서도 문제가 발생할 수 있다.
시스템콜을 통해 동작하는 방식이기 때문에, 커널이 중개자 역할을 하게 되는데 이때 송신 프로세스가 커널에게 메시지를 전달한 후 해당 메시지가 수신 프로세스에게 도착했는지를 확인할 수 없고,
만약 도착 여부를 모르는 상태에서 동일한 메시지를 커널에게 전달하게 되면 메시지 중복에 의한 오버헤드가 발생할 수 있다.

이 때, 동기적으로 처리할지 / 비동기적으로 처리할지 에 따라 다를 수 있다.

- Blocking : 동기적으로 처리 - 받은 결과가 올 때까지 나머지 접근에 대해서 block
- Non-Blocking : 비동기적으로 처리 - 막지 않고 그대로 반응

## 구현 방식
### (1) PIPE
- Messgae Passing Model
- 단방향으로 메시지를 전달하는 IPC 방법
- 부모가 같거나, 부모자식 관계에서만 사용 가능
- fd(file descripter)를 이용해서 연결해야하기 때문에 관계 없는 프로세스간 통신은 불가능
- ex) 쉘 : "|(파이프)"는 왼쪽의 stdout을 오른쪽의 stdin으로 입력하는 역할이다.
    ```shell
    $ ls | grep hello
    hello_world.c
    ```
  
pipe - golang 구현은 [여기](https://github.com/yumin00/IPC/blob/main/pipe/pipe.go)에서 확인할 수 있다.


### (2) FIFO(named pipe)
- Message Passing Model
- 파일을 이용해 메시지 전하는 IPC 방법
- PIPE와 다르게 부모가 다른 프로세스 간에도 IPC 통신 가능
- 파일을 통해 fd를 얻기 때문에 부모를 공유해야 한다는 제약이 없다.
- ex)

fifo - golang 구현은 [여기](https://github.com/yumin00/IPC/blob/main/main.go)에서 확인할 수 있다.

### (3) Message Queue
- Message Passing Model
- 메시지큐 자료구조는 커널에서 관리하기 때문에 프로세스 간 통신이 가능하다.
- sender 프로세스가 종료되어도 메시지가 사라지지 않는다.
- 특정 타입의 메시지만 선별적으로 받아올 수 있다.

direct이든 아니든, 임시의 queue 안의 프로세스들이 통신하여 message가 교환하게 된다. queue는 세 가지 방식으로 구현된다.
- Zero capacity : buffer가 0으로, 메시지를 보낼 때마다 block
- Bounded capacity : queue 길이가 n / n개의 메시지만 보낼 수 있음 / 꽉 차면 block
- Unbounded capacity : queue 길이가 무한대 / unblock

### (4) Memory Map
- Shared Memory Model
- 파일을 메모리의 주소 공간에 매핑하는 방식이다.
- 두 개 이상의 프로세스가 매핑된 파일의 내용을 통해 데이터를 공유하고 전달할 수 있다.
- 큰 파일을 작업할 때, 전체 파일을 메모리에 로드하지 않고 필요한 부분만 메모리에 매핑하여 사용함으로써, 메모리 사용을 최적화하고, 시스템 자원을 효율적으로 사용할 수 있게 한다.

### (5) Socket
- Message Passing Model
- 소켓은 네트워크 상에서 프로세스 간에 데이터 통신하는 방식이다.
- 클라이언트-서버 모델을 기반으로 동작한다.
  - 서버: 특정 포트에서 클라이언트의 연결 요청을 기다린다.
  - 클리아언트: 서버의 IP 주소와 포트 번호를 통해 서버에 연결한다.
- 양방향 통신이 가능하다.