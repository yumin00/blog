---
title: "네트워크 프로토콜 입문을 읽고-레이어3 프로토콜 이해하기"
date: 2026-01-20T22:25:45+09:00
draft: false
description: ""
categories :
- Network
---


## 네트워크 계층(Layer 3, L3)
- L2(데이터 링크 계층):
    - 같은 공간(같은 네트워크) 안에서 누구에게 보낼지 정해서 전달
    - L2 = 같은 캠퍼스 안: 같은 캠퍼스 안에서는 경제학과 건물 3층 305호만 알면 찾아갈 수 있음


- L3(네트워크 계층):
    - 다른 공간(다른 네트워크) 까지 포함해서 “어디로 가야 하는지” 경로를 결정
    - L3 = 캠퍼스와 캠퍼스를 잇는 도시: 다른 대학 캠퍼스를 가려면 어느 도시인지, 어느 대학인지, 어느 길로 가야할지 알아야 함

## IP (인터넷 프로토콜)
IP는 네트워크 상에서 “어디에 있는지”를 나타내는 논리적 주소다.

### IP 주소는 어떤 구조일까?
IPv4 예시: `192.168.1.10`


이 숫자는 의미 없이 붙은 게 아니라, 두 부분으로 나뉜다.

[네트워크 주소] [호스트 주소]


- 네트워크 주소: 어느 네트워크에 속해 있는지
- 호스트 주소: 그 네트워크 안에서 누구인지

👉 “서울시 강남구” + “101동 1001호” 같은 느낌

## 서브넷 마스크
### 서브넷 마스크는 왜 필요할까?
IP 주소 하나만 보면 이런 문제가 생긴다.

`192.168.1.10`


질문: 이 주소에서 어디까지가 네트워크, 어디부터가 개인(컴퓨터) 일까요?

👉 IP만으로는 알 수 없음

그래서 필요한 게 서브넷 마스크!

서브넷 마스크는 IP 주소에서 네트워크 부분과 호스트 부분을 구분해주는 기준선이다.

컴퓨터는 서브넷 마스크를 기준으로 스위치로 바로 보낼지, 라우터로 보낼지 결정한다.

### 실제 예시로 이해하기

내 컴퓨터의 네트워크 정보가 다음과 같다고 가정해보자.

```
내 IP 주소: 192.168.1.10
서브넷 마스크: 255.255.255.0
```

이제 두 가지 목적지로 데이터를 보내려고 한다.

#### 🎯 케이스 1: 목적지가 `192.168.1.20`인 경우

```
192.168.1.10    (내 IP)
192.168.1.20    (목적지)
```

서브넷 마스크 `255.255.255.0`을 적용하면:
- 네트워크 부분: `192.168.1` ✅ 동일
- 호스트 부분: `10`과 `20`

**결과:** ✔ 같은 네트워크 → 스위치를 통해 바로 전달!

#### 🎯 케이스 2: 목적지가 `192.168.2.20`인 경우

```
192.168.1.10    (내 IP)
192.168.2.20    (목적지)
```

서브넷 마스크 `255.255.255.0`을 적용하면:
- 네트워크 부분: `192.168.1`과 `192.168.2` ❌ 다름

**결과:** ❌ 다른 네트워크 → 라우터에게 전달!

### 서브넷 마스크 표기법

서브넷 마스크를 표현하는 방법에는 크게 두 가지가 있다.

- **10진수 표기**: 사람이 읽기 쉬운 방식
- **CIDR 표기**: 비트 개념을 간단하게 표현하는 방식

#### 📌 10진수 표기 (Dot Decimal Notation)

가장 직관적인 방식으로, 점으로 구분된 4개의 숫자로 표현한다.

```
예시: 255.255.255.0
```

익숙하고 이해하기 쉽지만, 길고 표현이 복잡할 수 있다는 단점이 있다.

#### 📌 CIDR 표기 (Classless Inter-Domain Routing/사이더)

슬래시(/) 뒤에 네트워크 비트 수를 표기하는 간결한 방식이다.

```
예시: /24
```

**읽는 법**:
- `/24` = "앞에서부터 24비트가 네트워크 주소다"
- 슬래시 뒤 숫자 = 네트워크 비트의 개수

**장점**:
- 매우 간결하다
- 계산과 설계에 유리하다
- 실무, 문서, 라우팅 설정에서 거의 표준으로 사용된다

#### 🔄 CIDR과 서브넷 마스크 변환표

| CIDR | 서브넷 마스크 | 네트워크 비트 수 |
|------|--------------|----------------|
| /8   | 255.0.0.0    | 8개            |
| /16  | 255.255.0.0  | 16개           |
| /24  | 255.255.255.0 | 24개          |
| /25  | 255.255.255.128 | 25개        |
| /26  | 255.255.255.192 | 26개        |

## 왜 CIDR이 중요한가?

### 📜 과거: 클래스 기반 주소의 한계

과거 인터넷은 **클래스 기반 주소 체계**를 사용했다.

```
Class A: 무조건 /8
Class B: 무조건 /16
Class C: 무조건 /24
```

**문제점:**
- 네트워크 크기가 고정되어 있어 유연성이 없음
- 작은 네트워크도 큰 주소 블록을 할당받아야 함
- IP 주소가 대량으로 낭비됨

👉 **너무 비효율적이다!**

### 🚀 현재: CIDR의 등장

CIDR은 이러한 문제를 해결하기 위해 등장했다.

**CIDR의 특징:**

1. **유연한 네트워크 분할**
   - 필요한 만큼만 네트워크를 나눌 수 있음
   - `/25`, `/26` 등 세밀한 조정 가능

2. **IP 주소 낭비 최소화**
   - 조직의 규모에 딱 맞는 주소 블록 할당
   - 제한된 IPv4 주소를 효율적으로 사용

3. **확장성**
   - 인터넷 규모 확장에 필수적인 기술
   - 라우팅 테이블 크기 최적화

👉 **CIDR은 현대 인터넷의 핵심 기술이다!**

## NAT (Network Address Translation)

NAT는 **내부 네트워크의 사설 IP를 외부 통신 시 공인 IP로 변환해주는 기술**이다.

### NAT는 왜 필요할까?

#### 핵심 문제: IPv4 주소 부족

IPv4 주소 체계는 이론적으로 약 **43억 개**의 주소를 제공한다. 하지만 전 세계 인터넷에 연결된 기기의 수는 이보다 훨씬 많다.

```
IPv4 주소 개수: 약 43억 개
전 세계 인터넷 연결 기기: 수백억 개 이상
```

👉 모든 기기에 공인 IP를 할당할 수 없다!

#### 해결책: NAT

NAT는 다음과 같은 방식으로 문제를 해결한다:

- **내부 네트워크**: 사설 IP 사용
- **외부 통신 시**: 공인 IP로 변환

👉 이 변환 작업을 담당하는 것이 바로 NAT이다!

### 🏠 실제 예시: 우리 집 네트워크

일반적인 가정의 네트워크 구조를 살펴보자.

```
📱 내부 기기 (사설 IP)
┌─────────────────────┐
│ 노트북: 192.168.0.10 │
│ 폰:    192.168.0.11 │
│ TV:    192.168.0.12 │
└─────────────────────┘
          ↓
    [ 공유기 (NAT) ]
          ↓
  🌐 공인 IP: 203.xxx.xxx.xxx
```

**결과:**
- 내부에는 **수십 개의 기기**가 각자의 사설 IP를 가짐
- 외부(인터넷)에서는 **단 하나의 공인 IP**로만 보임

이렇게 NAT는 하나의 공인 IP로 여러 기기가 인터넷을 사용할 수 있게 해준다.

## ICMP (인터넷 제어 메시지 프로토콜)
IP 통신으로는 패킷을 보냈는지, 중간에 문제가 생겼는지는 알 수가 없다. 그래서 문제가 생겼을 때 알려주는 역할을 ICMP가 담당한다. 즉, ICMP는 데이터 전달용이 아니라 오류와 상태를 알리는 용도다.

ICMP는 데이터를 보내지 않는다는 특징이 있다.

- ❌ ICMP로 파일 전송 → 불가능
- ❌ ICMP로 API 호출 → 불가능

오직 상태/오류 알림용으로, TCP, UDP 같은 전송 계층 프로토콜을 보조하는 역할이라고 볼 수 있다.

### ICMP는 언제 사용될까?
#### 예시 1️⃣ 목적지에 도달할 수 없을 때
목적지 서버가 꺼져있거나 라우터가 해당 네트워크를 모르면 ICMP 메시지로 알려준다.

`Destination Unreachable (목적지 도달 불가)`

#### 예시 2️⃣ 패킷이 너무 클 때
패킷이 너무 크면 라우터가 ICMP로 패킷이 너무 크니 다시 전송하라는 메시지로 알려준다.

`Fragmentation Needed`

#### 예시 3️⃣ ping
Echo Request : 살아있니?

Echo Reply : 응 살아있어!

즉, ping = ICMP 테스트 도구

## 라우터
라우터는 여러 네트워크를 연결하고 IP 패킷을 서로 다른 네트워크로 전송하는 네트워크 장비다.

라우터는 가정 내 LAN이라는 작은 네트워크의 IP 패킷을 큰 네트워크인 인터넷에 전송하는 역할을 한다.

## 라우팅
IP 패킷을 어느 쪽으로 보내야 목적지에 도착하는지 결정하는 과정

라우터는 스위치처럼 단순히 "연결된 곳으로 보내는 장비"가 아니다. 라우터는 항상 판단을 한다.

- 이 패킷은 어디로 가는가?
- 내가 직접 보낼 수 있는 곳인가?
- 아니면 다른 라우터에게 넘겨야 하는가?

### IP 패킷에서 라우팅에 필요한 정보

IP 패킷에는 여러 정보가 있지만, 라우팅에서 중요한 것은 하나다.

`목적지 IP 주소 (예: 203.0.113.25)`

라우터는 이 IP 주소를 보고 "이 IP는 어느 네트워크에 속하지?"를 확인한다.

### 라우팅 테이블
라우터는 **라우팅 테이블(Routing Table)**이라는 표를 가지고 있다. 라우터의 지도라고 볼 수 있다.

라우팅 테이블에는 항상 두 가지 핵심 정보가 들어 있다.

#### 1) 목적지 네트워크 (Destination Network)
- 패킷이 가고자 하는 IP 범위
- CIDR 형태로 표현됨

#### 2) 넥스트 홉 (Next Hop)
- 해당 목적지 네트워크로 가기 위해 다음에 전달할 장비의 IP 주소
- 보통 다음 라우터의 IP

### 라우터 동작 단계
1. 패킷의 목적지 IP 주소를 확인한다
2. 라우팅 테이블에서 해당 IP가 포함된 목적지 네트워크를 찾는다
3. 그 네트워크에 대응되는 넥스트 홉을 확인한다
4. 넥스트 홉의 IP 주소를 실제로 전달할 수 있는 MAC 주소로 변환해야 하므로, ARP 테이블을 조회한다
5. ARP 테이블에 MAC 주소가 있으면 해당 MAC 주소를 사용한다
6. ARP 테이블에 없다면 ARP Request를 브로드캐스트하여 MAC 주소를 학습한다
7. 확인된 MAC 주소를 목적지로 하여 이더넷 프레임을 구성하고 패킷을 전달한다


#### 기본 게이트웨이(Default Gateway)
이 패킷이 어디로 가야 할지 모르겠을 때, 일단 넘기는 라우터를 기본 게이트웨이라고 한다.

라우터 동작 단계 중 2번에서 라우팅 테이블에서 목적지 네트워크를 찾을 때 만약 아무 경로도 없다면 기본 게이트웨이를 사용한다.

`0.0.0.0/0 → 192.168.1.1`

### 정적 라우팅(Static Routing): 수동
- 관리자가 목적지 네트워크와 넥스트 홉을 직접 지정하는 방식
- 기본 게이트웨이도 정적 라우팅의 한 종류다.

### 동적 라우팅(Dynamic Routing)
- 인접한 라우터끼리 경로 정보를 교환하여 자동으로 라우팅 테이블을 구성하는 방식
- 경로 정보 교환을 위한 프로토콜을 라우팅 프로토콜이라고 함
   - OSPE(Open Shortest Path First): 링크 상태 기반, 빠르고 안정적
   - BGP(Boarder Gateway Protocol): 인터넷 전체 라우팅, 정책 기반


