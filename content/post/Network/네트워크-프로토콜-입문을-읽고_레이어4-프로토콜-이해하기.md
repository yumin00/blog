---
title: "네트워크 프로토콜 입문을 읽고_레이어4 프로토콜 이해하기"
date: 2026-01-26T22:53:35+09:00
draft: false
categories :
- Network
---

## 방화벽
방화벽은 네트워크 트래픽을 규칙에 따라 허용하거나 차단하는 보안 장치/기능이다.

방화벽은 패킷을 볼 때 주로 5가지 정보를 기준으로 판단한다.

- 출발지 IP
- 목적지 IP
- 출발지 포트
- 목적지 포트
- 프로토콜 (TCP / UDP / ICMP)

방화벽은 **명시적으로 허용된 것만 통과** 정책을 사용하는데 이를 **Default Deny, Whitelist 방식** 이라고 부른다.

### 예시
```
ALLOW  TCP  ANY      →  203.0.113.5:443
DENY   TCP  ANY      →  203.0.113.5:22
```

- HTTPS(443)는 허용
- SSH(22)는 차단

### 방화벽 종류
1) 패킷 필터링 방화벽

- 가장 단순
- IP, 포트, 프로토콜만 보고 판단
- 빠르지만 똑똑하진 않음

2) 상태 기반(Stateful) 방화벽

- “이 연결이 정상적인 흐름인가?”를 기억
- 현재 가장 많이 사용됨

3) 애플리케이션 방화벽 (WAF)

- HTTP 요청 내용을 이해
- SQL Injection, XSS 같은 웹 공격 방어
- 웹 서버 앞단에 위치

## 전송 계층(레이어 4 프로토콜)
먼저 지금까지 공부한 하위 계층에 대해 정리해보자.

- L1~L2: 실제로 데이터를 보내기 위한 물리적 전달
- L3 (네트워크 계층): 어느 컴퓨터까지 보낼지 (IP 주소)

L4(전송 계층)은 그 컴퓨터 안에서 어느 프로그램까지 보낼지 + 전송을 어떻게 할지를 결정하는 역할이다.

### 전송 계층은 왜 필요할까?
노트북에서 카카오톡으로 메시지를 전송하는 일과 크롬으로 유튜브를 시청하는 일이 동시에 벌어지고 있다고 가정해보자.

이 동작들은 모두 같은 노트북에서 이뤄지기 때문에 같은 IP 주소를 사용할 것이다. 하지만 서로 다른 프로그램에서 데이터를 주고 받고 있다.

그럼 데이터를 전달받은 입장에서는 같은 노트북 안에서도 어떤 프로그램에게 데이터를 전달해줘야 할지 어떻게 구분할 수 있을까? (이 데이터는 카카오톡으로 보내야돼? 아니면 크롬 유튜브로 보내야돼?)

이를 구분해 주는 역할이 바로 전송 계층이다!

### 핵심 역할
#### 포트 번호로 프로그램 구분하기
IP 주소로 어떤 컴퓨터인지 구분한다면, 포트를 통해서 그 컴퓨터 안의 어떤 프로그램인지 결정할 수 있다.

NAT를 공부하면서 외부에서 같은 공인 IP이더라도 포트를 통해서 각 기기를 구분한다고 했었는데, 여기에서 좀 더 자세히 말해보자면 포트로 기기를 구분하는 것이 아니라 기기 내 프로그램을 구분할 수 있는 것이다.

| 내부 IP | 내부 포트 | 공인 IP | 공인 포트 |
|---------|----------|---------|----------|
| 192.168.0.10 | 52344 | 203.0.113.5 | 40001 |
| 192.168.0.10 | 52345 | 203.0.113.5 | 40002 |

즉, NAT 환경에서 동일한 내부 IP에서 발생한 여러 통신은 내부 포트로 구분되며 외부로 변환될 때는 동일한 공인 IP를 사용하되 서로 다른 공인 포트를 할당하여 식별한다!

#### 프로세스 간 통신 (Process to Process)
- L3는 컴퓨터 ↔ 컴퓨터
- L4는 프로그램 ↔ 프로그램

그래서 전송 계층을 End-to-End Communication라고도 표현한다.


#### 신뢰성 있는 전송 or 빠른 전송 선택
전송 계층에서는 **"이 데이터를 얼마나 신뢰성 있게 보낼까?"**를 결정한다.

- TCP
- UDP

#### 데이터 분할 & 재조립
애플리케이션에서 보내는 데이터는 보통 크기 때문에 전송 계층에서는

- 큰 데이터를 작게 쪼개서(Segmentation) 보내고
- 받는 쪽에서 다시 순서대로 조립(Reassembly)한다.


## UDP (User Datagram Protocol)
- 연결을 만들지 않고 빠르게 데이터만 던지는 전송 계층 프로토콜
- 비연결성
    - 상태(state)를 유지하지 않는다
    - 이전에 무슨 패킷을 주고받았는지 기억하지 않는다
- 신뢰성 없음
- 빠름
- Datagram 단위

## TCP (Transmission Control Protocl)
연결을 기반으로 데이터의 신뢰성과 순서를 보장하는 전송 계층 프로토콜이다.

### TCP 헤더 필드
#### 발신자/목적지 포트 번호
어떤 프로그램에서 어떤 프로그램으로 데이터가 가는지 식별할 수 있다.

#### 시퀀스 번호
- TCP 세그먼트의 첫 번째 바이트 번호
- 순서를 보장하기 위함
- 애플리케이션 계층에서 전달된 바이트 스트림을 TCP 전송 계층이 내부적으로 관리하며 각 바이트에 대해 시퀀스 번호를 부여하여 세그먼트에 포함시킨다.

📌 예:
```
Seq = 1000, Data = 500 bytes
→ 다음 Seq = 1500
```

> 세그먼트란?
>
> - TCP가 데이터를 전송할 때 사용하는 하나의 전송 단위
> - 애플리케이션이 만든 큰 데이터를 TCP가 잘라서 하나씩 보내는 조각: 그 조각 하나가 세그먼트
> - 네트워크 한계 때문에 세그먼트로 나눔

#### 확인 응답 번호 (ACK 번호, Acknowledge 번호)
- 다음에 받고 싶은 바이트 번호
- ACK = 1500: 0~1499까지는 받았고, 1500을 받고 싶어.

#### 데이터 오프셋
- TCP 헤더 길이 ㅍ시
- TCP 헤더가 어디까지인지 알기 위함

#### 제어 비트
| 플래그 | 의미     |
| --- | ------ |
| SYN | 연결 시작  |
| ACK | 확인 응답  |
| FIN | 정상 종료  |
| RST | 강제 종료  |
| PSH | 즉시 전달  |
| URG | 긴급 데이터 |

#### 윈도우 크기
- 수신할 수 있는 데이터 크기를 알려주는 필드
- 흐름 제어의 핵심

#### 체크섬 (Checksum)
- 받은 TCP 세그먼트가 손상되지 않았는지, 무결성을 확인하는 데 사용되는 필드

#### 비상 포인터 (Urgent Pointer)
- 긴급 데이터를 나타내는 필드
- 현재 애플리케이션에서는 거의 사용하지 않음

#### 옵션
- TCP와 관련된 확장 기능을 서로에게 알리기 위해 사용


| 종류 | 옵션 헤더     |의미 
| --- | ------ |------ |
| 2 | MSS(Maximum Segment Size)  | 애플리케이션 데이터 최대 크기를 알린다  |
| 5 | SACK(Selective Acknowledgement)  | 이미 수신한 시퀀스 번호를 알려준다  |