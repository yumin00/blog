---
title: "TCP에 대해 알아보자"
date: 2023-08-15T21:25:00+09:00
draft: false
categories :
- Network
---

# TCP
## 1. TCP
### TCP가 생겨난 이유
IP만으로는 패킷 전달에 여러 한계점이 있다.

- 패킷을 받을 대상이 연결 상태임을 확인하지 않고 전송함
- 순서가 있는 여러 개의 패킷을 전송했을 때, 순서를 보장할 수 없음
- 패킷을 가지고 있던 호스트가 종료되어 패킷이 소실될 경우, 패킷이 목적지까지 가지 못하고 소실될 수 있음

TCP는 이러한 한계점을 위해 만들어졌다.

### TCP란?
TCP(Transmission Control Protocol)이란, 신뢰성 있는 데이터 통신을 위해 전송 제어를 위한 작업을 해주는 프로토콜이다.

IP는 오직 데이터를 주고받을 **주소**만을 위한 프로토콜이지만, TCP는 주소들이 주고받을 **데이터**가 온전한지를 확인해주는 프로토콜이다.

TCP의 패킷 유실 문제 해결 방법
1. TCP는 어떤 패킷이 사라졌는지 확인하기 위해 패킷마다 번호를 붙인다.
2. TCP는 클라이언트가 데이터를 받으면, 서버에게 데이터를 잘 받았다는 메세지를 전송한다.
3. 서버가 클라이언트에게 데이터를 잘 받았다는 메세지를 받지 못하면, 데이터 전송 과정에 오류가 생겼음을 인지하고 다시 데이터를 보내, 클라이언트가 데이터를 받을 수 있게 보장한다.

### 헤더 / 플래그
IP를 포함해 모든 프로토콜은 데이터의 앞에 헤더라는 정보를 추가해 전송한다. 헤더 안에는 해당 데이터에 대한 정보가 담겨 있다.(데이터가 들어있는 것이 아니라, 데이터의 정보가 들어있음)

TCP는 데이터의 신뢰를 담당하는 프로토콜이기 때문에, 헤더에 많은 정보가 들어가있다. 그중에서도 패킷의 상태를 알리는 목적의 헤더 정보인 **플래그**가 있다.

플래그는 다른 기기에 신호를 전달하기 위한 용도로, 플래그의 활성화 여부에 따라 다른 의미를 전달할 수 있다.

[플래그의 종류]
- ACK(Acknowledgement)
  - 앞서 받은 데이터를 잘 처리했다는 의미를 가지는 플래그
- SYN(Synchronize)
  - 연결을 요청하는 플래그
- FIN(Finish)
  - 통신이 마무리되어 연결의 해제를 요청하는 플래그

> (예시)
>
> 플래그 : ACK : 1 / SYN : 1
>
> =
> 상대방이 보낸 데이터를 잘 처리했다(ACK) / 나도 상대방에게 연결해도 되는가?(SYN)

## 2. 연결형 프로토콜, TCP
TCP는 신뢰성 있는 통신을 위한 프로토콜로, 데이터를 주고받기 전에 미리 클라이언트와 서버가 서로 통신할 준비가 됐는지 확인하고, 연결 오류로 이한 데이터 유실을 방지한다. -- **연결형 프로토콜**

### 3방향 핸드셰이크
TCP는 3방향 핸드셰이크 방식을 사용해 연결을 수립한다.

ex) 클라언트가 서버에게 고양이 사진을 받고 싶다고 요청했다
1. 클라이언트는 서버에 연결하고 싶다는 패킷 전송 >> 플래그 SYN = 1
- SYN이 켜져있어야 서버는 이 패킷이 연결을 시작하고 싶다는 요청이라는 것을 알 수 있다.
2. 클라이언트는 자기의 상태를 연결을 요청한 상태(SYN_SENT)로 바꿔 서버의 답장을 기다림
3. 서버는 클라이언트의 패킷을 확인했다는 답장과 동시에 자신도 클라이언트에서 연결하고 싶다는 요청의 패킷을 전달 >> 플래그 ACK = 1, SYN = 1
4. 서버는 클라이언트의 연결 요청을 받은 상태(SYN_RECEIVED)로  바뀜
5. 클라이언트는 ACK 플래그를 보고 연결해도 된다고 생각해, 자신의 상태를 연결됨(ESTABLISHED)으로 변경하고, SYN에 대한 답장으로 자신 또한 서버에 ACK 메세지를 전달
6. 서버는 답장을 확인한 뒤, 자신의 상태를 연결되었다고 바꿈으로써 연결에 성공함

==> 3방향 핸드쉐이크는 클라이언트와 서버가 각각 연결 요청을 보내고, 서로 확인했다는 응답을 받으면 연결에 성공하는 방식으로 동작한다.

### 4방향 핸드쉐이크
TCP는 더이상 보낼 데이터가 없는데 연결을 지속하는 곳은 비효율적으로 생각해 데이터 통신이 끝나면 연결을 끊는 과정을 거친다. 이러한 연결 종료 방식을 4방향 핸드셰이크라고 한다.

1. 필요한 데이터를 전부 받았다고 생각한 클라이언트는 서버에게 FIN 플래그가 담긴 패킷을 보내고, 종료를 기다리는 상태(FIN_WAIT)로 변경한다.
2. 연결 종료 요청을 받은 서버는 확인했다는 ACK 메세지를 보낸다.
3. 그리고 미처 보내지 못한 패킷을 마저 보내며 자신의 통신이 끝날 때까지 기다리는 상태(CLOSE_WAIT)가 된다.
4. 시간이 지난 뒤, 서버가 자신 또한 연결을 종료할 준비가 되었다면 클라이언트에게 FIN 플래그를 전송하고 ACK 플래그를 기다리는 상태(LAST_ACK)가 된다.
5. 마지막으로 클라이언트는 서버에게 ACK 플래그가 담긴 패킷을 보내 연결을 종료한다.(TIME_WAIT)
6. 해당 플래그를 받은 서버는 종료한다.(CLOSED)

3방향 핸드셰이크와 달리, 클라이언트와 서버의 마지막 상태가 서로 다른데, 그 이유는 클라이언트는 미처 받지 못한 패킷이 들어오는 등 혹시 모를 상황에 대비해 잠시 기다렸다가(TIME_WAIT) 지정된 시간이 지나면 연결을 종료하는 상태(CLOSED)로 바뀌기 때문이다.

TCP는 서로 연결하고 해지하는 과정을 거치면서 안전하게 데이터를 주고 받는다.

## 3. 흐름제어
패킷은 순서대로 전송되고, 순서대로 조립되는 것이 중요하다. 외부 상황으로 인해 데이터가 유실되거나 순서가 잘못되어 수신되는 경우가 있는데, 이런 상황은 언제 발생하고 어떻게 해결할 수 있을까?

### 흐름제어란?
TCP가 정상적으로 데이터를 받지 못하는 원인 중 하나는, 전송자와 수신자 간에 데이터 속도 차이가 발생했을 경우이다.

이럴 때, 전송자와 수신자의 데이터 속도 차이로 인한 오류를 줄이기 위해 수신자의 처리 속도에 맞춰 전송자의 통신 속도를 제어하는 것을 **흐름 제어** 라고 한다.

### 정지-대기 방식
흐름 제어에는 **정지-대기 방식**이 있다.

정지-대기 방식이란, 매번 전송한 패킷에 대해 확인 응답을 받은 뒤에 다음 패킷을 전송하는 방법이다.

전송자가 데이터를 보내면, 수신자가 이를 받고나서 ACK 플래그를 보내 잘 받았다는 응답을 한다. 답장이 오지 않거나, ACK 플래그가 아닌 다른 플래그가 활성화되어 있으면 전송자는 수신자가 제대로 데이터를 
받지 못했다고 판단하여 같은 내용을 재전송한다.

정지-대기 방식은 요청마다 일일이 확인 응답을 받아야 하고, 답장이 없으면 다음 데이터를 전송할 수 없어 시간이 오래 걸리고 효율이 떨어진다는 문제로 오늘날에는 거의 사용하지 않는다.

### 슬라이딩 윈도
또 다른 흐름제어로는 **슬라이딩 윈도**가 있다.

슬라이딩 윈도란, 수신자가 받을 수 있을 만큼만 데이터를 보내는 것이다.

윈도 크키는 주로 수신자가 한 번에 처리할 수 있는 데이터의 크기로, 헤더의 구성 요소이다. 처음 전송자와 수신자가 연결하는 3방향 핸드셰이크 과정에서 윈도 크기가 정해진다.

[슬라이딩 윈도 방식]
1. 전송자는 위도 크기만큼 데이터를 순서대로 전달한다.
2. 수신자는 받은 데이터를 처리하고 ACK 패킷을 보낸다. 이때, 메시지 헤더 안에 마지막으로 받은 데이터의 번호가 몇 번이었는지 전달한다.
3. 전송자는 몇 번재 데이터까지 전송되었는지 확인하고 그다음 순서부터 윈도 크기만큼 데이터를 전달한다.

## 4. 혼잡 제어
### 혼잡제어란?
전송자의 데이터는 지역망 또는 인터넷 네트워크를 통해 전달된다. 이때 한 네트워크에 데이터가 집중되면 해당 네트워크를 사용하는 데이터의 처리 속도는 떠러진다. 
하지만 전송자와 수신자는 이에 대해 알 수 없기 때문에 수신자는 데이터를 다시 보내달라는 요청을 하고, 전송자는 데이터가 유실되었다고 판단하여 재전송하게 된다. 그럼 네트워크에 더 많은 데이터가 몰려 상황이 악화된다.

네트워크 내 패킷의 수가 과도하게 증가하는 현상을 혼잡이라고 하며, 이를 제어하는 기능을 **혼잡 제어** 라고 한다.

### 혼잡제어의 원리
네트워크의 상태는 그때마다 바뀌기 때문에 혼잡도를 단번에 파악할 수 없다.

혼잡제어 방식은 대부분 처음에는 데이터르 천천히 보내다가, 수신자가 잘 받는 것을 확인하면 점차 속도를 높이는 방식으로 제어한다. 그러다, 수신자가 한참 전에 전달한 데이터까지만 받았다고 얘기하면 그때 네트워크가 혼잡하다는 사실을 인지하고 속도를 줄인다.

### 합 증가/ 곱 감소, 느린 시작
혼잡 제어 방법으로는 **합 증가/곱 감소(AIMD)** 와 **느린 시작** 이 있다.

[합 증가/곱 감소]
- 처음에 전송자가 수신자에게 패킷을 하나씩 보낸 뒤, 잘 도착했다는 응답을 받으면 윈도 크기를 1개씩 증가시키면서 전송하는 방법
- 네트워크가 혼잡하다고 판단되면 윈도 크기를 절반으로 줄여 네트워크가 안정되기를 기다림
- 안전하게 네트워크를 사용할 수 있다.
- 전송 속도가 천천히 증가하기 대문에 초기 전송 속도를 높이는 데 걸리는 시간이 길다.

[느린 시작]
- 윈도 크기를 1로 시작해 서서히 개수를 늘리는 방법
- 윈도 크기가 2배씩 증가
- 네트워크가 혼잡하다고 판단되면 윈도 크기를 1로 급격히 줄임
- 시간이 지날수록 많은 양의 데이터를 전달할 수 있다.
- 이전까지는 수신자가 받을 수 있는 만큼 최대한 전달했다면, 느린 시작 방식에서는 보내는 양을 1부터 서서히 늘려가기 때문에 느린 시작이라고 한다.

현재 TCP에서는 처음에는 느린 시작을 사용하다가 특정 지점을 넘기면 합 증가/곱 감소로 변경하는 등 각 상황에 맞는 방법을 조합한 혼잡 제어 정책을 선택해 사용하고 있다.

## 5. UDP
### TCP 단점
TCP의 최대 단점은 전송 속도가 느리다는 것이다.

데이터를 꼼꼼하게 확인하기 위해 패킷에 대한 응답을 해야하기 때문에(시간 지연, CPU 소모) 전송 속도가 늦고 성능이 낮다. 또한, 패킷이 손실될 경우 다시 전송하기 때문에 스트리밍 서비스에 적합하지 않다.

이를 해결하기 위해 UDP(User Datagram Protocol)가 생겨났다.

### UDP
UDP(User Datagram Protocol)은 이름 그대로 데이터를 데이터그램 단위로 처리하는 프로토콜이다. 데이터그램이란, 독립적인 관계를 지닌 패킷이라는 뜻이다.
TCP에서는 패킷을 전달하고, UDP에서는 패킷이 아닌 데이터그램을 전송한다고 한다.

UDP는 비연결형 프로토콜로, 연결을 위해 할당되는 논리적인 경로가 없다.
그렇기 때문에 각각의 데이터그램은 다른 경로로 전송되고, 각각의 데이터그램은 독립적인 관계를 지니게 되는데 이렇게 데이터를 서로 다른 경로로 독립적으로 처리하는 프로토콜을 UDP라고 한다.

### TCP와 UDP의 차이점
UDP는 TCP와 비슷하게 데이터를 전송하는 역할을 하지만, 신뢰성을 보장하지 않음으로써 속도를 빠르게 개선한 프로토콜이다.

[UDP 프로토콜의 특징]
- UDP는 전송자와 수신자 사이에 연결되어 있는지 보장하지 않는다
  - 즉, 전송자가 일방적으로 데이터를 전달하는 프로토콜이다. 따라서 3방향 핸드셰이크처럼 서로 잘 연결되었는지 확인하는 절차도 없다.
  - UDP 헤더의 CheckSum 필드를 통해 최소한의 오류를 검출한다.
  - TCP를 연결형 프로토콜이라고 불렀다면, UDP는 비연결형 프로토콜이라고 한다.
- UDP는 데이터그램 사이의 의존성이 없다.
  - 즉, 데이터그램을 순서대로 전달할 필요가 없다.
  - 데이터그램킷은 상황에 맞게 가장 빠른 최적의 경로를 찾아 이동하고, 도착한 순서대로 처리된다.
  - 데이터그램의 헤더에 데이터의 번호나 플래그 같이 안전성을 확보하기 위한 정보가 빠져있기 떄문에 같은 내용의 데이터라도 TCP에 비해 용량이 가볍다.
- UDP는 TCP의 혼잡 제어처럼 스스로 전송 속도를 제어하는 기능이 없다.
  - 처음에 정한 속도 그대로 데이터를 전송한다.
  - 중간에 데이터 속도가 지연되지 않고, 일정한 속도를 보장할 수 있다.
  - 많이 사용하면 네트워크가 혼잡해질 수 있다는 단점이 있다.

UDP는 신뢰성보다 연속성이 중요한 곳에서 사용한다. UDP는 프레임이 1~2개 정도 잠깐 보이지 않아도 괜찮은 실시간으로 화면을 보여주는게 중요한 스트리밍 방송이나 온라인 게임에서 주로 사용한다.