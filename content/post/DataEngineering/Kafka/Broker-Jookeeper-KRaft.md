---
title: "Broker Jookeeper KRaft"
date: 2024-03-13T21:42:31+09:00
draft: false
categories :
- DataEngineering
- Kafka
---

패스트캠퍼의 `한번에 끝내는 Kafka Ecosystem` 강의 내용을 바탕으로 Broker, Jookeeper, KRaft를 정리해보고자 한다. 

# Broker
![image](https://github.com/yumin00/blog/assets/130362583/480ebd43-2bb2-4795-8716-bd8d671ef55a)

- producer가 메시지를 프로듀스하면 받아서 저장하고, consumer가 메시지를 컨슘하면 메시지를 전달해주는 역할
- 카프카 서버라고 부르기도 한다.
- 파티션들을 분산, 유지, 관리
- 각 브로커들은 아이디로 식별 (ex. 101, 102, ..) 할 수 있는데, 이때 브로커 아이디와 파티션의 아이디는 관련이 없다.
- 토픽의 일부 파티션을 가진다. 토픽에 여러 개의 파티션이 있더라도 한 브로커가 모든 파티션을 가지고 있는게 아니라, 일부만 가지고 있는다.
- 토픽을 구성하는 파티션들은 여러 브로커에 분산된다.
- 토픽을 생성하면 카프카가 자동으로 토픽을 구성하는 파티션들을 모든 브로커에 분배하여 할당한다.
- 카프카 클러스터는 여러 개의 브로커로 구성된다.
- 클라이언트가 특정 브로커에 연결하면 전체 클러스터에 연결된다.
- 최소 3대 이상의 브로커를 하나의 클러스터로 구성해야 된다.
  - 4대 이상 권장(Jookeeper 모드에서) -> 업그레이드 모드에서 브로커를 순차적으로 셧다운 할 때, 정상 동작할 수 있게 하기 위해서
  - KRaft 모드에서는 3대 이상을 권장

## Bootstrap servers
- 브로커 서버들을 의미한다. 즉, 브로커들을 bootstrap server라고 부르기도 한다.
- 클라이언트가 하나의 브로커에만 연결해도 클러스터 전체에 연결된다.
  - 특정 브로커의 장애에 대비하여, 전체 브로커 리스트(IP, port)를 파라미터로 입력하는 것을 권장하고 있다.
- 각 브로커들은 모든 브로커, 토픽, 파티션에 대해 알고 있음 (metadata를 공유하기 때문에)

### 클라이언트가 브로커에 연결하는 과정
1. 클라이언트가 브로커에게 연결을 요청하고 metadata를 요청함
2. 브로커가 살아있으면, 모든 브로커의 리스트, 모든 토픽/파티션의 정보를 전달함


# Jookeeper
![image](https://github.com/yumin00/blog/assets/130362583/d98c9c3b-d503-461a-85f6-b1d68808c1d5)

- 브로커 토픽 파티션들의 목록, 설정, 상태 등을 관리해주는 소프트웨어이다.
- Jookeeper는 변경사항이 생기면 카프카에 알림을 준다. 예를 들어, 토픽이 생성되거나 삭제되는 일이 발생하면 알림을 주고 브로커들을 동기화시켜준다.
- 홀수 개의 서버로 작동하게 설계되어 있다. (3개 or 5개)
- 점점 Jookeeper 모드는 사라지는 중!
- Jookeeper 없는 방식을 KRaft mode라고 한다.
- 리더(writes)와, 나머지 서버 followers(readers)가 있다.

## Jookeeper 아키텍처
- leader/follower 기반의 master/slaver 아키텍처
- 만약 브로커1에 문제가 생기면 해당 브로커1을 보고 있던 팔로워가 이를 리더에게 알리고 리더는 팔로워들에게 다시 이 사실을 알리고, 각 Jookeeper들이 자신이 관할하고 있는 브로크에게 이 사실을 알려서 동기화하는 방식이다.
- 분산형 configuration 정보 유지
- 분산 동기화 서비스 제공
- 대용량 분산 시스템을 위한 네이밍 레지스트리 제공

## Jookeeper fail over 알고리즘 = quroum 알고리즘
- ensemble : Jookeeper 서버의 클러스터
- quroum:  동기화된 데이터가 정말 맞는지 합의하는데 필요한 최소한의 인원수 (과반 초과) -> 그렇기 때문에 홀수개로 만들어져야 한다.
  - ensemble이 3개라면, Jookeeper 1대에 장애가 발생하더라도 정상 동작


# KRaft mode
- Jookeeper 모드를 없앤 모드
- 브로커와 Jookeeper는 서로 완전 다른 소프트웨어이기 떄문에 둘 다 관리해야해서 복잡성이 증가한다는 단점이 있다. 이로 인해 [KIP-500: Jookeeper는 제거하자] 라는 이슈를 통해 Jookeeper 모드가 사라진 KRaft mode가 생겼다.
- KRaft = kafka + raft
- Jookeeper가 하는 일을 브로커 내에 구현한 아키텍처이다. 

## 장점
- Jookeeper가 하는 일을 향상시켰다: 메타데이터 관리, 상태 정보 관리, 브로커 상태 변경 시 분산 처리
- Jookeeper를 사용하지 않고 브로커만 관리하면 되기 때문에 카프카 관리와 배포를 단순화시켰다.
- 안정성과 장애 조치 성능이 향상됐다.
  - 예상치 못한 장애시, recovery 타임이 Jookeeper 모드보다 크라프트 모드가 더 짧다.