---
title: "IPC"
date: 2023-08-23T13:08:43+09:00
draft: false
---

# IPC
## 1. IPC 개념
**프로세스는 독립적으로 실행된다.**

**IPC(Inter Process Communication)** 란 프로세스 간의 통신을 위한 매커니즘이다.

이때,프로세스란 무엇일까?

---

> ### 프로세스
프로세스는 실행 중인 프로그램을 의미한다. 그렇다면 프로그램은 무엇일까?

프로그램이란, 명령어들의 모음을 포함한 디스크에 저장된 파일이다. 프로그램이 실행되면, 명령어들과 데이터가 메모리에 적재되고 이것이 프로세스가 된다.

> ### 프로세스 메모리 구조
<img width="300" alt="image" src="https://github.com/yumin00/blog/assets/130362583/cea79ecd-9aa4-4f00-9366-9a39f48fcb25">

> ### 프로세스 스케줄링
하나의 CPU로 프로세스를 동시에 실행시킬 수 없다. 그래서 CPU는 여러 프로세스를 일정한 기준으로 순서를 정해서 실행한다. CPU 할당 순서 및 방법을 결정하는 과정을 프로세스 스케줄링이라고 한다.

---

프로세스는 독립적으로 실행되기 때문에, 서로 간에 통신이 어렵다는 문제가 있다. 커널 영역에서는 IPC라는 내부 프로세스간 통신을 제공한다.
> 커널영역?
> 
> 프로세스 메모리의 코드 영역, 데이터 영역, 힙 영역, 스택 영역은 사용자 영역으로, 이를 제외한 나머지 영역이 커널영역이다.
> 
> 운영체제 코드는 커널 영역에서만 실행 가능하고, 사용자는 시스템 콜을 통해 커널 영역을 실행할 수 있다.

IPC 모델에는 **Shared Memory**, **Message Passing** 이 있다.

## 2. IPC 모델 - Shared Memory
**Shared Memory(메모리 공유)** 는 프로세스끼리 공통의 메모리 영역을 상호간 통신하는 방법이다.

데이터 자체를 공유하도록 지원하며, 한 프로세스에서 변경한 메모리 공간의 내용을 다른 프로세스에서 접근할 수 있다. 공유 메모리는 커널에서 관리된다.

이는 성능은 좋지만, 동기화 문제가 발생힌한다.
### 동기화 문제
동시에 공유 자원에 접근하는 것은 데이터의 일관성을 해칠 수 있다. 프로세스들의 실행 순서를 정하여 공유 자원의 일관성을 보장하는 것을 동기화(Synchronization)라고 한다.

IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해, **세마포어**와 **뮤텍스**를 사용한다.


## 3. IPC 모델 - Message Passing
### Message Passing(메시지 전달)
**Message Passing(메시지 전달)** 은 커널이 제공하는 API를 이용하여 커널 공간을 통해 통신하는 방식이다.

송신 프로세스가 커널로 메시지를 보내면 그걸 커널이 수신 프로세스에게 보내주는 것이다.

**direct communication** 은 송신 프로세스가 커널에 메시지를 주고, 그걸 커널이 수신 프로세스에게 직접 전달하는 것이다.

**indirect communication** 은 송신 프로세스가 '커널에 m0 이라는 메시지 박스에 넣어놓을테니 가져가' 라고 하면, 수신 프로세스가 커널에서 abc 메시지 박스를 찾아 읽어오는 방식이다.

### 장단점
커널의 중계를 통해 메시지를 전달하며 큐를 사용하여 비교적 안전하다.

하지만 무언가를 거치기 때문에 커널의 한 구석에 저장 공간이 필요하고, 직접 전달하는 것보다 속도가 느리다. 또한 매번 system call이 호출되고, Queue에 저장하고 꺼내는 과정에서 발생하는 
Overhead로 인해 효율성이 떨어진다.
> Overhead(오버헤드)
> 
> 프로그램 실행 도중에 동떨어진 위치의 코드를 실행시켜야할 때, 추가적으로 시간/메모리/자원이 사용되는 현상

메시지 전달 방식에서도 IPC간의 문제가 발생할 수 있다. 전달할 내용이 도착하기도 전에, 또 보내라는 신호를 보내면 문제가 생길 것이다.

이 때, 동기적으로 처리할지 / 비동기적으로 처리할지 에 따라 다를 수 있다.

- Blocking : 동기적으로 처리 - 받은 결과가 올 때까지 나머지 접근에 대해서 block
- Non-Blocking : 비동기적으로 처리 - 막지 않고 그대로 반응

### Queue 구현 방식
direct이든 아니든, 임시의 queue 안의 프로세스들이 통신하여 message가 교환하게 된다. queue는 세 가지 방식으로 구현된다.
- Zero capacity : buffer가 0으로, 메시지를 보낼 때마다 block
- Bounded capacity : queue 길이가 n / n개의 메시지만 보낼 수 있음 / 꽉 차면 block
- Unbounded capacity : queue 길이가 무한대 / unblock

<img width="1471" alt="image" src="https://github.com/yumin00/blog/assets/130362583/b2224069-d99e-4196-b0fb-fb622cf98e32">

## 4. IPC 구현 방법
### (1) PIPE
- 단방향으로 메시지를 전달하는 IPC 방법
- 부모가 같거나, 부모자식 관계에서만 사용 가능
- fd(file descripter)를 이용해서 연결해야하기 때문에 관계 없는 프로세스간 통신은 불가능
- ex) 쉘 : "|(파이프)"는 왼쪽의 stdout을 오른쪽의 stdin으로 입력하는 역할이다.
    ```shell
    $ ls | grep hello
    hello_world.c
    ```
  
### (2) FIFO(named pipe)
- 파일을 이용해 메시지 전하는 IPC 방법
- PIPE와 다르게 부모가 다른 프로세스 간에도 IPC 통신 가능
- 파일을 통해 fd를 얻기 때문에 부모를 공유해야 한다는 제약이 없

### (3) 메세지 큐
- 메시지큐 자료구조는 커널에서 관리하기 때문에 프로세스 간 통신이 가능하다.
- sender 프로세스가 종료되어도 메시지가 사라지지 않는다.
- 특정 타입의 메시지만 선별적으로 받아올 수 있다.

[구현 방법]
- SysV : 상대적으로 오래됐기 때문에 기능이 제한적이고, 필요한 인자가 많음
- Posix : API가 직관적이고, 제공하는 기능이 많음.
  - 멀티플렉싱 API로 관리 가능
  - 메시지 큐에 대한 notify 제공
  - 멀티 쓰레드에 안전

### (4) 소켓(Socket)
- 동일한 호스트 운영 체제에서 실행되는 프로세스간 데이터를 교환하기 위한 데이터 통신 엔드 포인트
- 네트워크 소켓 통신을 통해 데이터 공유
- 원격에서 프로세스 간 데이터를 공유할 때 사용

### (5) 공유 메모리
- 오버헤드가 발생하지 않기 때문에 대량의 데이터를 공유할 때 적합
- 메시지 방식의 IPC보다 안전성과 사용성이 떨어짐
- SysV방식과 Posix 방식의 라이브러리 구현체가 있다.

다음에는 IPC 구현 방법을 좀 더 공부해보고, 직접 구현을 해보고자 한다.