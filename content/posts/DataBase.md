---
title: "데이터 설계"
date: 2023-08-02T17:06:24+09:00
draft: false
---

어제(8월 1일)부터 뮤지컬 캘린더 어플리케이션을 만드는 팀 프로젝트를 진행하기 시작했다.

백엔드 개발자를 맡아, 제대로된 프로세스 안에서 진행해보고자 먼저 데이터 설계에 대해 공부하려고 한다.


## 1. 데이터 설계
### 데이터 설계란?
- 데이터베이스에 저장할 테이블의 구조를 디자인
- 기본키, 외래키, 인데스 등의 관리 요소 계획

### 데이터 설계 절차
1. 요구 사항 분석
- 시스템 구축을 위해 필요한 데이터 분석
- 해당 데이터를 어떻게 관리할지 요구사항 명세서, 프로세스 설계서, 인터페이스 설계서를 참고
> **요구사항 명세서(SRS, Software Requirements Specification)**
> 
> 서비스를 구현하기 위해서는 다양한 요구사항이 거론되는데, 이를 명확히 정리한 것이 요구사항 명세서다.
> 
> 소프트웨어 시스템이 수행해야 할 모든 기능과 구현상의 제약 조건에 대해 관련된 사람이 모두 합의한 스펙에 대한 사항을 명세한다.

>**인터페이스 설계서**
> 
> 각 시스템의 교환 데이터 및 송수신 주체 등이 정의되어 있다.

2. 개념 데이터 설계
- 관리하고자 하는 정보와 그 정보 간에 어떤 관계가 있는지 설계

3. 논리 데이터 설계
- `개념 데이터 설계` 단계에서 도출한 정보의 속성을 정의
- 식별자(Primary Key) 확정
- 정규화 수행
> **정규화**
> 
> 테이블 간에 중복된 데이터를 허용하지 않는다는 것

4. 물리 데이터 설계
- 상용 데이터 베이스에서 적용할 수 있도록 속성을 구체적으로 정의
- 타입, 크기, 제약사항 정리
- 데이터 관리의 효율성과 속도에 초점을 맞춰 비정규화를 일부 수행

5. 테이블 정의서 작성
- 테이블, 컬럼에 대한 주석을 추가해서 최종적으로 개발에 활용한 테이블 정의서 작

### 데이터 설계도구 ERD
**ERD(Entity Relationship Diagram: 개체 관계 다이어그램)** 는 크게 개체, 관계, 속성으로 구성된다.
- 개체
  - 데이터 수집의 대상이 되는 사물
  - 각 개체는 속성으로 정의됨
  - 일반적으로 개체는 테이블로 변환됨
- 관계
  - 개체들 간의 연관성
  - ex) 1:N
- 속성
  - 개체가 가지고 있는 특징
  - 개체는 테이블로 변환되기 때문에, 속성은 컬럼으로 변환

### ERD 작성 절차
1. 개체 선정
2. 관계 설정
3. 속성 정의
4. 식별자 정의

## 2. 정규화
정규화의 기본 목표는 테이블 간에 중복된 데이터를 허용하지 않는다는 것이다. 이는 **무결성**을 유지할 수 있으며, DB의 저장용량도 줄일 수 있다.

### 제 1 정규화
테이블 컬럼이 하나의 값을 갖도록 하는 것이다.

<img width="188" alt="image" src="https://github.com/yumin00/blog/assets/130362583/2985657d-3f1a-4c66-8432-eda3ffca50d1">

짱구는 두 개의 값을 가지고 있기 때문에 제 1 정규형을 만족하지 못하고 있다.

<img width="183" alt="image" src="https://github.com/yumin00/blog/assets/130362583/bfb3fef2-5f12-4acd-8d83-e9bd9788b76a">

이러한 테이블이 제 1 정규화를 만족하고 있다고 할 수 있다.

### 제 2 정규화
제 2 정규화란 제 1 정규화를 진행한 테이블을 완전 함수 종속으로 만족하도록 테이블을 분해하는 것이다.
> 완전 함수 종속
> 
> 기본키의 부분집합이 결정자가 되어서는 안됨

<img width="366" alt="image" src="https://github.com/yumin00/blog/assets/130362583/b18db373-0279-4a33-9587-3050d8e47751">

이 테이블의 기본키는 (`이름`, `강좌`)로 복합키이다. (`이름`, `강좌`) 기본키를 통해 성적을 알 수 있다. 여기서 `강의실` 컬럼은 기본키의 부분집합인 `강좌` 컬럼에 의해 결정될 수 있다.

즉, 기본키(`이름`, `강좌`)의 부분키인 `강좌`가 결정자이기 때문에 `강의실`을 분해하여 제 2 정규형을 만족시킬 수 있다.

<img width="551" alt="image" src="https://github.com/yumin00/blog/assets/130362583/f9763133-d47b-444c-8268-91fc3045231b">

이를 통해, 첫 번째 테이블에서는 기본키(`이름`,`강좌`)가 성적을 결정하고, 두 번째 테이블에서는 `강좌`가 `강의실`을 결정한다.

### 제 3 정규화
제 3 정규화란 제 2 정규화를 진행한 테이블에 대해 이행적 종속이 없도록 분해하는 것이다.
> 이행적 종속
> 
> A > B / B > C 일 때, A > C 가 성립되는 것

<img width="276" alt="image" src="https://github.com/yumin00/blog/assets/130362583/2ba7d6a1-b6b2-4712-ab84-aeffd97725a4">

해당 테이블에서 `이름`은 `강좌`를 결정하고 있고, `강좌`는 `수강료`를 결정하고 있다. 그렇기 때문에 테이블 분리가 필요하다.

<img width="461" alt="image" src="https://github.com/yumin00/blog/assets/130362583/83a377e4-a4b1-4e4e-a281-67134000f02e">

제 3 정규화가 필요한 이유는 다음과 같다.

만약 짱구가 강좌를 독서로 변경하면, 수강료는 6,000원인 강좌를 2,000원에 듣는 것이다. 수강료를 변경하면 되지만 이러한 번거로움을 해결하기 위해서 테이블을 분리하면,

짱구가 듣는 강좌를 독서로 변경하면 이를 참조하여 짱구가 내는 수강료는 6,000원이 되는 것이다.

### BCNF 정규화
BCNF 정규화란 제 3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것이다.

<img width="279" alt="image" src="https://github.com/yumin00/blog/assets/130362583/8b236f79-715f-4dd8-9b2c-6682b91041eb">

해당 테이블에서 기본키는 (`이름`, `강좌`)이다. `이름`과 `강좌`는 `교수`를 결정하고 있다. 그리고 `교수`는 `강좌`를 결정하고 있다.

하지만 문제는 `교수`가 후보키가 아니라는 것이다. BCNF 정규화를 만족시키기 위해서는 다음과 같이 테이블을 분리해야한다.

<img width="460" alt="image" src="https://github.com/yumin00/blog/assets/130362583/c7364a73-70a2-47be-ae60-53ba3b656a0f">