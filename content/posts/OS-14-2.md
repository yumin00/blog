---
title: "OS 14(2) - 페이징을 통한 가상 메모리 관리"
date: 2023-07-26T21:33:59+09:00
draft: true
---

## 14-2 페이징을 통한 가상 메모리 관리
**가상 메모리** 는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.
가상 메모리 관리 기법에는 **페이징** 과 **세그멘테이션** 이 있다.
### 페이징이란
**페이징** 이란, 프로세스의 논리 주소 공간을 **페이지** 단위로 자르고,
메모리 물리 주소 공간을 **프레임** 단위로 잘라 페이지를 프레임에 할당하는 것이다.

페이징에서도 스와핑이 가능하다.
프로세스 전체가 스왑 아웃/인 되는 것이 아닌, 페이지 단위로 스왑 아웃/인 된다.

페이징 시스템에서는 **페이지 아웃** / **페이지 인** 이라고 부르기도 한다.

즉, 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요는 없다는 것이다.
당장 실행에 필요한 페이지만 메모리에 적재하고, 그렇지 않은 페이지들은 보조기억장치에 남겨둘 수 있다.

### 페이지 테이블
페이징 기법을 통해 프로세스가 메모리에 불연속적으로 배치되어있다면, CPU는 해당 프로세스를 순차적으로 실행할 수 없다.
프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있는 것은 어렵기 때문이다.

이를 해결하기 위해 페이징 시스템은
프로세스가 실제 메모리 내의 주소인 물리 주소에 불연속적으로 배치되어도,
CPU가 바라보는 주소인 논리주소에는 연속적으로 배치되도록 페이징 테이블을 이용한다.

**페이지 테이블** 을 통해 페이지가 적재된 프레임을 찾을 수 있다.

해당 페이징 기법을 통해 CPU는 논리 주소를 순차적으로 실행하면 된다.


프로세스마다 각자의 프로세스 테이블을 가지고 있다. CPU 내의 **페이지 테이블 베이스 레지스터(PTBR)** 은 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다. 페이지 테이블 정보들은 각
프로세스의 PCB에 기록된다.
다음은 프로세스 실행 시 발생되는 순서이다.

1. 프로세스 A가 실행됨
2. PTBR은 프로세스 A의 페이지 테이블을 가리킴
3. CPU는 프로세스 A의 페이지 테이블을 통해 프로세스 A의 페이지가 적재된 프레임을 알 수 있음

페이지 테이블을 메모리에 두면, < 메모리에 있는 페이지 테이블을 보기 위해 / 알게 된 프레임에 접근하기 위해 > 메모리에 두 번 접근하게 된다.

이 문제를 해결하기 위해 CPU 곁에는 **TLB** 라는 페이지 테이블의 캐시 메모리를 둔다. TLB는 페이지 테이블 캐시로, 페이지 테이블의 일부 내용을 저장한다.
참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 가져와 저장한다.

CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우, **TLB 히트** 라고 한다. 없는 경우, **TLB 미스** 라고 한다.

### 페이징에서의 주소 변환

페이지와 프레임은 여러 주소를 포괄하고 있다. 그렇기에 특정 주소에 접근하려면

- 어떤 페에지/프레임에 접근하고 싶은지
- 접근하려는 주소가 그 페이지/프레임 으로부터 얼마나 떨어져 있는지

페이징 시스템에서는 모든 논리 주소가 기본적으로 **페이지 번호** 와 **변위** 로 이루어져 있다.
변위는 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지를 알기 위한 정보이다.

논리주소 <페이지 번호, 변위>는 페이지 테이블을 통해 물리주소 <프레임 번호, 변위> 로 변환된다.

### 페이지 테이블 엔트

페이지 테이블의 각각의 행들을 **페이지 테이블 엔트리(PTE)라고 한다. 페이지 테이블 엔트리에 담기는 정보로는 페이지 번호, 프레임 번호뿐만 아니라 유효 비트 / 보호 비트/ 참조 비트 / 수정 비트 가 있다.

< 유효 비트 >

프로세스르 이루는 모든 페이지는 메모리 내에 위치하지 않는다. 사용되지 않는 페이지는 보조기억장치(스왑 영역)에 있다.
유효 비트는 현재 페이지가 메모리에 적재되어 있는지, 보조기억장치에 있는지를 알려주는 비트이다.

메모리에 적재되어 있다면 유효 비트는 1, 메모리에 적재되어 있지 않다면 0이 된다.

만일 유효 비트가 0이라면, **페이지 폴트** 라는 예외가 발생한다. CPU가 페이지 폴트를 처리하는 과정은 하드웨어 인터럽트를 처리하는 과정과 유사하다.
1. CPU는 기존의 작업 내역을 백업
2. 페이지 폴트 처리 루틴 실행
3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경
4. 페이지 폴트를 처리했다면 CPU는 해당 페이지에 접근 가능

< 보호 비트 >

보호 비트는 페이지 보호 기능을 위해 존재한다. 보호 비트를 통해 페이지가 읽기, 쓰기 중 가능한 것을 나타낼 수 있다.

프로세스를 이루는 요소 중 코드 영역은 읽기 전용 영역인데, 만약 이러한 읽기 전용 페이지에 쓰기를 시도한다면 운영체제가 이를 막아주어 페이지를 보호한다.

보호 비트는 세 개의 비트로 구현할 수도 있다.
- r : Read
- w : Write
- x : eXecute

< 참조 비트 >

CPU가 이 페이지에 접근한 적이 있는지 여부를 나타낸다. 적재 이후 읽거나 쓴 페이지는 참조 비트가 1이 되고, 아닌 페이지는 0이 된다.

< 수정 비트 >

해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려준다. **더티 비트** 라고도 한다. 비트가 1이면 변경된 적이 있는 페이지이다.

수정 비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지 판단하기 위해 존재한다.